# Python 中的符號

## 底線（`_`）

在 Python 中，底線（`_`）在變量和函數名稱中的使用有特殊的意義。根據底線的數量及位置，它們的用途各不相同。以下是常見的底線使用情況及其意義：

### 1. **單個底線 `_`**

#### 1.1 作為上一個計算結果的臨時變量

在 Python 互動式解釋器中，單個底線 `_` 用來存儲最後執行語句的結果。例如：

```python
>>> 5 + 3
8
>>> _ + 2
10
```

在這裡，`_` 是前一個表達式（`5 + 3`）的結果 `8`。

#### 1.2 用來表示忽略的變量

單個底線也可以用來表示你打算忽略的變量，通常在不需要使用的情況下。例如，當只關心迴圈的次數而不需要變量值時：

```python
for _ in range(5):
    print("Hello")
```

這裡的 `_` 表示我們不會使用迴圈中的變量。

### 2. **單前置底線 `_var`**

這種命名方式代表該變量或函數是「**私有的**」或「**內部使用的**」，不應該從模塊或類之外直接訪問。這是一種編碼上的約定，並不會阻止外部使用該變量或函數，但表示這些內容應該視為實現細節。

```python
class MyClass:
    def __init__(self):
        self._private_var = 10  # 私有變量

    def _private_method(self):
        print("This is a private method.")
```

### 3. **雙前置底線 `__var`**

雙前置底線用於名稱改寫（**name mangling**），主要在類中使用，以避免名稱與子類中的名稱衝突。Python 會自動將雙前置底線的變量名稱改寫為 `_ClassName__var`，從而避免名稱衝突。例如：

```python
class MyClass:
    def __init__(self):
        self.__private_var = 10  # 名稱會被改寫

obj = MyClass()
print(obj.__private_var)  # AttributeError: 'MyClass' object has no attribute '__private_var'
```

實際上，變量名被改寫為 `_MyClass__private_var`，這樣在繼承時可以避免意外覆蓋。

```python
print(obj._MyClass__private_var)  # 可以訪問這個變量
```

### 4. **雙前後底線 `__var__`**

這種用法通常保留給 Python 的內建方法和屬性，這些名稱具有特殊意義，被稱為**魔術方法**（magic methods）。例如：

* `__init__`：初始化對象時調用。
* `__call__`：使對象可被調用時運行（像函數一樣運行）。
* `__str__`：用於將對象轉換為字符串。

通常情況下，你不應該隨意定義帶有雙前後底線的變量或方法名稱，這些名稱有特定的用途。

```python
class MyClass:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return f"MyClass with name {self.name}"

obj = MyClass("Example")
print(obj)  # 自動調用 __str__ 方法
```

### 5. **單後置底線 `var_`**

當某個變量名稱是 Python 關鍵字（如 `class`, `def` 等），或者變量名稱與已有名稱衝突時，通常會在變量名稱後加一個單後置底線來區分。例如：

```python
class_ = "some value"  # 'class' 是關鍵字，不能直接使用
```

### 總結

* **單底線 `_`**：表示忽略的變量或上次表達式的結果。
* **單前置底線 `_var`**：表示內部使用，表達「私有性」的約定。
* **雙前置底線 `__var`**：啟用名稱改寫，避免名稱衝突。
* **雙前後底線 `__var__`**：Python 的內建方法和屬性名稱，不應隨意使用。
* **單後置底線 `var_`**：避免與關鍵字或已有名稱衝突。

### 這些是Python的規定嗎？

這些不同形式的底線幫助 Python 程式碼保持清晰、結構化，並避免意外的名稱衝突。

這些底線的使用規範不是正式的規定或語法，而是 Python 社區的約定和慣例。這些慣例旨在提高代碼的可讀性和可維護性。以下是對這些約定的更詳細說明：

#### 1. **單底線 `_`**

* **使用場景**：作為臨時變量或表示不會使用的變量。
* **社區慣例**：這是一種約定，讓開發者知道該變量的用途和意義。雖然 Python 語言本身不會強制執行，但這種慣例在許多開源項目和開發中得到廣泛使用。

#### 2. **單前置底線 `_var`**

* **使用場景**：表示該變量或方法是「私有的」或「內部使用的」。
* **社區慣例**：這種命名約定主要用於告訴使用者這個變量或方法不應被外部代碼直接訪問。這是通過慣例來傳遞信息，而不是通過強制的語法規定。

#### 3. **雙前置底線 `__var`**

* **使用場景**：啟用名稱改寫以避免名稱衝突。
* **社區慣例**：這個慣例告訴開發者這個變量是用於內部實現，可能會受到名稱改寫的影響，特別是在繼承的情況下。Python 會自動改寫名稱以避免衝突，但這依賴於語言的設計而非語法強制。

#### 4. **雙前後底線 `__var__`**

* **使用場景**：定義 Python 的內建方法和屬性。
* **社區慣例**：這些名稱是由 Python 語言本身保留的，通常稱為**魔術方法**或**特殊方法**。這些名稱具有特定功能，開發者在創建自定義類時也不應隨意使用。

#### 5. **單後置底線 `var_`**

* **使用場景**：用於避免與 Python 關鍵字或已有名稱衝突。
* **社區慣例**：這是一種方便的方式來創建有效的變量名稱，而不必因為命名衝突而導致語法錯誤。

#### 總結

這些約定和慣例是 Python 社區中的廣泛實踐，幫助開發者編寫更清晰、易於維護的代碼。雖然它們不是強制的語法規定，但遵循這些慣例是 Python 編程的一部分，能夠提升代碼的可讀性和可維護性，並減少潛在的錯誤。在參與開源項目或與其他開發者合作時，遵循這些約定尤其重要。
